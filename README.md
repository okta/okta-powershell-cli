# Okta.PowerShell - The PowerShell module for the Okta Management API

* [Release status](#release-status)
* [Need help?](#need-help)
* [Getting started](#getting-started)
* [Usage guide](#usage-guide)
* [Contributing](#contributing)

This repository contains the Okta management PowerShell module. This PowerShell module can be used to easily interact with the Okta management API and:
 
* Create and update users with the [Users API](https://developer.okta.com/docs/api/resources/users)
* Add security factors to users with the [Factors API](https://developer.okta.com/docs/api/resources/factors)
* Manage groups with the [Groups API](https://developer.okta.com/docs/api/resources/groups)
* Manage applications with the [Apps API](https://developer.okta.com/docs/api/resources/apps)
* Manage logs with the [Logs API](https://developer.okta.com/docs/api/resources/system_log)
* Manage sessions with the [Sessions API](https://developer.okta.com/docs/api/resources/sessions)
* Manage templates with the [Custom Templates API](https://developer.okta.com/docs/reference/api/templates/)
* Manage identity providers with the [Identity Providers API](https://developer.okta.com/docs/reference/api/idps/)
* Manage authorization servers with the [Authorization Servers API](https://developer.okta.com/docs/reference/api/authorization-servers/)
* Manage event hooks with the [Event Hooks Management API](https://developer.okta.com/docs/reference/api/event-hooks/)
* Manage inline hooks with the [Inline Hooks Management API](https://developer.okta.com/docs/reference/api/inline-hooks/).
* Manage features with the [Features API](https://developer.okta.com/docs/reference/api/features/).
* Manage linked objects with the [Linked Objects API](https://developer.okta.com/docs/reference/api/linked-objects/).
* Manage trusted origins with the [Trusted Origins API](https://developer.okta.com/docs/reference/api/trusted-origins/).
* Manage user types with the [User Types API](https://developer.okta.com/docs/reference/api/user-types/).
* Manage custom domains with the [Domains API](https://developer.okta.com/docs/reference/api/domains/).
* Manage network zones with the [Zones API's endpoints](https://developer.okta.com/docs/reference/api/zones/).
* Much more!

> Note: For more details about the APIs and models the SDK support, check out the [API docs](/API_README.md) 

## Release status

This library uses semantic versioning and follows Okta's [library version policy](https://developer.okta.com/code/library-versions/).

| Version | Status                    |
| ------- | ------------------------- |
| 2.x | :heavy_check_mark: Stable |
| 1.x | :warning: Retiring on Aug 21st 2025 |
 
The latest release can always be found on the [releases page][github-releases]. For more information about our SDKs' lifecycle, check out [our docs](https://developer.okta.com/code/library-versions/).

## Need help?
 
If you run into problems using the Okta PowerShell module, you can
 
* Ask questions on the [Okta Developer Forums][devforum]
* Post [issues][github-issues] here on GitHub (for code errors)


## Getting started

This PowerShell module is automatically generated by the [OpenAPI Generator](https://openapi-generator.tech) project:

- API version: 3.0.0
- Build package: org.openapitools.codegen.languages.PowerShellClientCodegen
    For more information, please visit [https://developer.okta.com/](https://developer.okta.com/)

<a id="frameworks-supported"></a>
The Okta PowerShell module is compatible with:

- PowerShell 7.0 or later
- Mac/Windows
- OIE and Classic Okta orgs

<a id="installation"></a>
## Installation

### PSGallery

To install the Okta.PowerShell module from [PS Gallery](https://www.powershellgallery.com/packages/Okta.PowerShell) run the following command:

```powershell
Install-Module -Name Okta.PowerShell -RequiredVersion <MODULE_VERSION>
```

To verify the module was successfully installed, run `Get-InstalledModule -Name 'okta.powershell'` and verify that the module information is shown.

To uninstall the module, simply run:
```powershell
Uninstall-Module -Name Okta.PowerShell
```

### Chocolatey

To install the Okta.PowerShell module from [Chocolatey](https://community.chocolatey.org/packages/okta.powershell) run the following command:

```powershell
choco install okta.powershell --version=<MODULE_VERSION>
```

To verify the module was successfully installed, run `choco list "okta.powershell"` and verify that the module information is shown.

To uninstall the module, simply run:
```powershell
choco uninstall okta.powershell
```

### GitHub

> Note: Signed binary releases are posted to the okta-powershell-cli releases section in Github. 

To install from the source, run the following command to build and install the PowerShell module locally:

```powershell
./Build.ps1
Import-Module -Name '.\src\Okta.PowerShell' -Verbose
```

To avoid function name collision, one can use `-Prefix`, e.g. `Import-Module -Name '.\src\Okta.PowerShell' -Prefix prefix`

To uninstall the module, simply run:
```powershell
Remove-Module -FullyQualifiedName @{ModuleName = "Okta.PowerShell"; ModuleVersion = "<MODULE_VERSION>"}
```

<a id="tests"></a>
#### Tests

To install and run `Pester`, please execute the following commands in the terminal:

```powershell
Install-module -name Pester -force

Invoke-Pester
```

For troubleshooting, please run `$DebugPreference = 'Continue'` to turn on debugging and disable it with `$DebugPreference = 'SilentlyContinue'` when done with the troubleshooting.

## Security recommendations

We recommend limiting the access permissions of your Okta.PowerShell scripts to only authorized users. 

Add the appropriate users or groups and assign the necessary permissions to the `OktaConfiguration.ps1` file (Full Control, Read & Execute, etc.), and remove any unnecessary users or groups from the list.

:Warning: The `OktaConfiguration.ps1` file contains secrets, so we recommend using least privilege access to the configuration file.

> Note: For more information about PowerShell script security, check out [the official PowerShell security guide](https://learn.microsoft.com/en-us/mem/configmgr/apps/deploy-use/learn-script-security).

## Usage guide

### Prerequisites 

The PowerShell module uses the [device authorization flow](https://developer.okta.com/docs/guides/device-authorization-grant/main/) to obtain an access token, so it requires, at least, three configuration values. These are the
values for the [Okta Org domain](https://developer.okta.com/docs/guides/find-your-domain/main/), the client ID of the [OIDC Native Application](https://developer.okta.com/blog/2021/11/12/native-sso) 
and the scope for the API grants you are going to need. For example, if you are going to get groups then you will need the grant `okta.groups.read` configured in your scope. Make sure to assign the application to anyone that needs access to it.

### non-admin users

Non-admin users will require to be granted specific permissions to perform certain tasks and access resources.

Check out the following resources to learn more:
* [Custom admin roles](https://help.okta.com/en-us/content/topics/security/custom-admin-role/work-with-admin.htm)
* [Standard admin roles and permissions](https://help.okta.com/en-us/content/topics/security/administrators-admin-comparison.htm)

### Set your configuration and execute commands 

1. Set your configuration

```powershell
$Configuration = Get-OktaConfiguration
$Configuration.BaseUrl = 'https://myorg.okta.com'
$Configuration.ClientId = 'MY_CLIENT_ID'
$Configuration.Scope = "okta.groups.read" # or "okta.groups.read okta.apps.read"
```

2. Authorize your device

```powershell
Invoke-OktaEstablishAccessToken
```
> Note: You have to open the browser and navigate to the provided URL to complete the flow. Once the device is authorized, go back to the PowerShell terminal.

3. Invoke commands

```powershell
Invoke-OktaListGroups

id                    : 00g9erf7s3ydK79IX5d7
created               : 5/5/23 1:45:05 PM
lastUpdated           : 5/5/23 1:45:05 PM
lastMembershipUpdated : 5/5/23 1:45:05 PM
objectClass           : {okta:user_group}
type                  : OKTA_GROUP
profile               : @{name=Sales; description=}
_links                : @{logo=System.Object[]; users=; apps=}
```

> Note: For more details about commands, check out the [documentation for API endpoints](/API_README.md)

> Note: If you want to remove the access token from configuration you can execute `Invoke-OktaRemoveAccessToken`

### Configure a proxy

```powershell
$proxyUrl = "http://127.0.0.1:8888"
$webProxy = New-Object System.Net.WebProxy($proxyUrl)
$Configuration.Proxy = $webProxy
```
4. Revoke your access token

Starting in Okta.PowerShell v2.x series, you can execute the following command to [revoke your token](https://developer.okta.com/docs/guides/revoke-tokens):

```powershell
Invoke-OktaRevokeAccessToken
```
Notice this will also remove the access token from your Okta configuration

### Create objects

The Okta PowerShell Module supports two approaches for object creation: 

1. The "Initialize-Object" command 
2. Using PowerShell's native `PSCustomObject` for creating objects

#### Create the object manually using PowerShell's native `PSCustomObject` and the [API reference](https://developer.okta.com/docs/api/openapi/okta-management/guides/overview/)

You can check out the API reference to explore what the payload structure should look like for the operation you want to perform. For example, if you want to create a group, check out the [Add Group API reference](https://developer.okta.com/docs/api/openapi/okta-management/management/tag/Group/#tag/Group/operation/addGroup) and look for the request sample. For this particular operation, you will see that the payload should look like the following:

```json
{
    "profile": {
        "description": "All users West of The Rockies",
        "name": "West Coast users"
    }
}
```

Then you can recreate the same payload using `PSCustomObject`:

```powershell
$Group = [PSCustomObject]@{ 
            profile = [PSCustomObject]@{
                description = "All users West of the Rockies"
                name = "West Coast users"}
    }

$NewGroup = New-OktaGroup -Group $Group
```

:warning: If you follow this approach, you have to ensure the casing is correct. Notice that for this particular operation, all the properties of the group payload are in lowercase.

#### Create the object using "Initialize-Object" command 

The Okta PowerShell Module provides an "Initialize-Object" command that simplifies the creation and initialization of most of the objects. Each object represents a distinct entity supported by the Okta PowerShell Module, and this command provides a standardized approach to create and configure these objects. 

Following the same "Create group" example as in the previous step, you can create a group object by executing the corresponding "Initialize-Object" commands:

```powershell
$GroupProfile = Initialize-OktaGroupProfile -Name "West Coast users" -Description "All users West of the Rockies"
$Group = Initialize-OktaGroup -VarProfile $GroupProfile
$NewGroup = New-OktaGroup -Group $Group
```

Notice that for objects that have nested properties, each nested property may itself be an object that needs to be initialized separately. In such cases make sure to:

1. Initialize each nested property individually.
2. Pass the nested object(s) as part of the -Property parameter when initializing the parent object.

Always verify the required structure and types for nested properties by consulting the [API reference](https://developer.okta.com/docs/api/openapi/okta-management/guides/overview/).

### Get a user

```powershell
$User = Get-OktaUser -UserId "foo"
```         

### Create a user

```powershell
$UserProfile = [PSCustomObject]@{
                firstName = 'John'
                lastName = 'Doe'
                login = 'john.doe@mail.com'
                email = 'john.doe@mail.com'
            }

$CreateUserRequest = Initialize-OktaCreateUserRequest -VarProfile $UserProfile -GroupIds 'foo'
$TestResult = New-OktaUser -Body $CreateUserRequest
```

> Note: If you initialize objects using `PSCustomObject`, ensure the casing is correct.

### Create a user with password

```powershell
$UserProfile = [PSCustomObject]@{
                firstName = 'John'
                lastName = 'Doe'
                login = 'john.doe@mail.com'
                email = 'john.doe@mail.com'
            }

$UserCredentials = [PSCustomObject]@{ 
                    password = [PSCustomObject]@{ value = 'Hell0W0rld'} 
                }

$CreateUserRequest = Initialize-OktaCreateUserRequest -VarProfile $UserProfile -Credentials $UserCredentials
$TestResult = New-OktaUser -Body $CreateUserRequest
```
> Note: If you initialize objects using `PSCustomObject`, ensure the casing is correct.

Alternatively, you can use the Initialize commands to create the user payload:

```powershell
$UserProfile = Initialize-OktaUserProfile -Email "joe.doe@mail.com" -Login "joe.doe@mail.com" -FirstName "Joe" -LastName "Doe"
$UserCredentials = Initialize-OktaUserCredentials -Password "Hell0W0rld!"

$CreateUserRequest = Initialize-OktaCreateUserRequest -VarProfile $UserProfile -Credentials $UserCredentials
$TestResult = New-OktaUser -Body $CreateUserRequest
```
### List users with pagination

```powershell
$Users  = Invoke-OktaListUsers -Limit 10 
```

Utilize the `-withHttpInfo` flag to retrieve additional response properties, including `NextPageUri` for accessing the subsequent page of results. Additionally, you can seamlessly access all response headers through the Headers property.

To paginate results, use `Uri` param, which allows passing absolute URIs:

```powershell
$UsersResponse  = Invoke-OktaListUsers -Limit 10 -withHttpInfo

While ($UsersResponse.NextPageUri)
{
    $UsersResponse = Invoke-OktaListUsers -Uri $UsersResponse.NextPageUri  -withHttpInfo #This time you can pass the absolute Uri with already contains query params such as "limit" or/and "after"
    $UsersList =  $UsersResponse.Response
}
```

### Create an application

```powershell
$OAuthClient = [PSCustomObject]@{
                client_uri = "https://example.com/client"
                logo_uri = "https://example.com/assets/images/logo-new.png"
                response_types = @("token", "id_token", "code")
                redirect_uris = @("https://example.com/oauth2/callback", "myapp://callback")
                post_logout_redirect_uris = @("https://example.com/postlogout", "myapp://postlogoutcallback")
                grant_types = @("implicit", "authorization_code")
                application_type = "native"
                tos_uri = "https://example.com/client/tos"
                policy_uri = "https://example.com/client/policy"
            }
# a simple test to create an object
$Settings = Initialize-OktaOpenIdConnectApplicationSettings -OauthClient $OAuthClient

$NewApp = Initialize-OktaOpenIdConnectApplication -Label "New App" -SignOnMode "OPENID_CONNECT" -Settings $Settings

```

> Note: If you initialize objects using `PSCustomObject`, ensure the casing is correct.

> Note: Null values are removed from the payload by default. If you want to include null values you have to include the `-IncludeNullValues` flag.

> Note: For more API samples checkout our [tests](https://github.com/okta/okta-powershell-cli/tree/main/tests/)

### List resources that match a filter criteria

Certain Okta APIs allow you to list a subset of resources that match a supported filter expression, query, or search criteria. For example, the Groups API enables you to provide filter criteria via query parameters to return a subset of groups. **These query parameters require URL encoding, which is handled internally by the Okta.PowerShell module**. This ensures that your queries are correctly formatted and processed by the Okta API without any additional effort on your part.

#### List groups using the `search` parameter

* Search groups that are of the type `OKTA_GROUP`:

```powershell
Invoke-OktaListGroups -Search 'type eq "OKTA_GROUP"'
```

Internally, the Okta.PowerShell module will encode the search criteria as `/api/v1/groups?search=type+eq+%22OKTA_GROUP%22`.

* Search groups which name is equals to `IAM Team`:

```powershell
Invoke-OktaListGroups -Search 'profile.name eq "IAM Team"'
```
Internally, the Okta.PowerShell module will encode the search criteria as `/api/v1/groups?search=profile.name+eq+%22IAM+Team%22`.

#### List groups using the `filter` parameter

* Filter groups that are of the type `OKTA_GROUP` with profile updated after 11/11/2015

```powershell
Invoke-OktaListGroups -Filter 'type eq "OKTA_GROUP" and lastUpdated gt "2016-11-11T00:00:00.000Z"'
```

Internally, the Okta.PowerShell module will encode the filter criteria as `/api/v1/groups?filter=lastUpdated+gt+%222015-10-05T00%3a00%3a00.000Z%22`.

* Filter groups by ID

```powershell
$GroupId = "00g6hmia52o0aTHx35d7"
Invoke-OktaListGroups -Filter "id eq `"$GroupId`""
```
> Note: Notice `$GroupId` is enclosed in double quotes.

Internally, the Okta.PowerShell module will encode the filter criteria as `/api/v1/groups?filter=id+eq+%2200g6hmia52o0aTHx35d7%22`.

#### List groups using the `q` parameter

Finds a group that matches the name property

```powershell
Invoke-OktaListGroups -Q "everyone"
```

### Get logs

Since the System Log API requires `since` and `until` query params to be ISO 8601 compliant timestamp, make sure to format dates accordingly:

```powershell
$since = (Get-Date).AddMonths(-6).ToString("yyyy-MM-ddTHH:mm:ssZ")
$until = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
Get-OktaLogs -since $since -until $until

```

## Error Handling 

Starting in Okta.PowerShell 2.x series we introduced a new exception called `OktaApiException` which is thrown when requests to the Okta API result in 4xx/5xx errors. You can catch an `OktaApiException` and access the Okta API error details. For example, if the API returns a 429 response with the following content: `{"errorCode":"E0000047","errorSummary":"API call exceeded rate limit due to too many requests.","errorLink":"E0000047","errorId":"oae6dB62BdhRFCF_9ltxiklFQ","errorCauses":[]}`, you can access these details from the exception:

```powershell
    try{
        $Result = Invoke-OktaListApplications
    }
    catch{
        $_.Exception.StatusCode.Value__ | Should -Be 429;
        $_.Exception.ErrorCode | Should -Be "E0000047"
        $_.Exception.ErrorSummary | Should -Be "API call exceeded rate limit due to too many requests."
        $_.Exception.ErrorLink | Should -Be "E0000047"
        $_.Exception.ErrorId | Should -Be "oae6dB62BdhRFCF_9ltxiklFQ"
        $_.Exception.ErrorCauses | Should -BeNullOrEmpty
        $_.Exception.Headers | Should -Not -Be $null
    }

```

## Rate Limiting

The Okta API will return 429 responses if too many requests are made within a given time. Please see [Rate Limiting at Okta] for a complete list of which endpoints are rate limited.  When a 429 error is received, the `X-Rate-Limit-Reset` header will tell you the time at which you can retry. This section discusses  methods for handling rate limiting with this SDK.

### Built-In Retry

The Okta.PowerShell module uses a built-in retry strategy to automatically retry on 429 errors.

You can configure the following options when using the built-in retry strategy:

| Configuration Option | Description |
| ---------------------- | -------------- |
| RequestTimeout         | The waiting time in milliseconds for a request to be resolved by the client. Less than or equal to 0 means "no timeout". The default value is `$null` (None). |
| MaxRetries             | The number of times to retry. |

If the request still fails with a 429 status code after retrying it the specified number of times or if the Okta API returns an Http error other than 429 after retying a request, an `OktaApiException` will be ultimately thrown.

### Usage

```powershell
$Config = Get-OktaConfiguration
$Config.MaxRetries = 2
$Config.RequestTimeout = 6000 

# Invoke your commands as usual
$Result = Invoke-OktaListApplications 
```

### Clarify the Role of ApiKey and ApiKeyPrefix

The ApiKey property contains the API token, and ApiKeyPrefix should be used to prefix the token when setting the Authorization header.
The OktaConfiguration object includes two important properties for API authentication:
ApiKey: This should contain the actual API token in the form of a hashtable, e.g., @{ apitoken = '<yourApiToken>' }.
ApiKeyPrefix: This is an optional prefix (default: "SSWS") to be used before the API token when setting the Authorization header.
Example Usage:
```powershell
$Configuration = Get-OktaConfiguration
$Configuration.BaseUrl = 'https://your-org.okta.com'
$Configuration.ApiKey = @{ apitoken = '<yourApiToken>' }
$Configuration.ApiKeyPrefix = "SSWS"  # Optional, defaults to "SSWS"
```
The resulting HTTP header will be:
```powershell
Authorization: SSWS <yourApiToken>
```
### Manually Set the Authorization Header
To ensure that the API call uses the correct Authorization header, you can set the Authorization header manually:

Example Usage:
```powershell
$Configuration = Get-OktaConfiguration
$Configuration.BaseUrl = 'https://your-org.okta.com'
$Configuration.DefaultHeaders = @{
    authorization = "$($Configuration.ApiKeyPrefix) $($Configuration.ApiKey.apitoken)"
}
```
This will automatically set the Authorization header as expected.

If you find the ApiKey and ApiKeyPrefix not functioning as expected, you can manually set the Authorization header using the following approach:

```powershell
$Configuration = Get-OktaConfiguration
$Configuration.BaseUrl = 'https://your-org.okta.com'
$Configuration.DefaultHeaders = @{ authorization = 'SSWS <yourApiToken>' }
This will ensure the header is set properly while we review the configuration behavior.
```

> Note: We're happy to accept contributions and PRs! Please see the [contribution guide](CONTRIBUTING.md) to understand how to structure a contribution.

[devforum]: https://devforum.okta.com/
[lang-landing]: https://developer.okta.com/code/dotnet/
[github-issues]: https://github.com/okta/okta-sdk-dotnet/issues
[github-releases]: https://github.com/okta/okta-powershell-cli/releases
[Rate Limiting at Okta]: https://developer.okta.com/docs/api/getting_started/rate-limits
